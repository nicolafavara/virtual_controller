{% extends "controller/_base.html" %}

{% block content %}
<section>
  <div class="collapse show" id="collapsediv1">
    <div class="row">
      <div class="col text-center">
        <div>
          <button id="btn_dir_up" type="button" class="btn3d btn btn-default btn-lg">Up</button>
          <br>
          <button id="btn_yaw_ccw" type="button" class="btn3d btn btn-default btn-lg">Yaw<br>(CCW)</button>
          <button id="btn_yaw_cw" type="button" class="btn3d btn btn-default btn-lg">Yaw<br>(CW)</button>
          <br>
          <button id="btn_dir_down" type="button" class="btn3d btn btn-default btn-lg">Down</button>
        </div>
      </div>
      <div class="col text-center">
        <div>
          <button id="btn_dir_north" type="button" class="btn3d btn btn-default btn-lg">North</button>
          <br>
          <button id="btn_dir_west" type="button" class="btn3d btn btn-default btn-lg">West</button>
          <button id="btn_dir_east" type="button" class="btn3d btn btn-default btn-lg">East</button>
          <br>
          <button id="btn_dir_south" type="button" class="btn3d btn btn-default btn-lg">South</button>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col text-center">
      <button id="button_guided" type="button" class="btn3d btn btn-default btn-lg">Guided<br>mode</button>
    </div>
    <div class="col  text-center">
      <button id="button_arm" type="button" class="btn3d btn btn-default btn-lg">Arm</button>
    </div>
    <div class="col  text-center">
      <button id="button_takeoff" type="button" class="btn3d btn btn-default btn-lg">Takeoff</button>
    </div>
    <div class="col  text-center">
      <button id="button_land" type="button" class="btn3d btn btn-default btn-lg">Land<br>Mode</button>
    </div>
  </div>
  <br>
  <div class="row">
    <div class="col">
      <label for="degrees" class="form-label">Degrees for yaw:</label>
      <input type="range" class="form-range" id="degrees" oninput="this.nextElementSibling.value = this.value" min="0"
        max="25" value="0">
      <output>0</output>
    </div>
  </div>
  <br>
  <div class="row">
    <div class="col">
      <label for="velocity" class="form-label">Velocity(m/s):</label>
      <input type="range" class="form-range" id="velocity" oninput="this.nextElementSibling.value = this.value" min="0"
        max="15" value="0">
      <output>0</output>
    </div>
  </div>

  <br><br>

  <div class="row">
    <div class="col">
      <div class="form-check form-switch text-center">
        <input class="form-check-input" type="checkbox" id="controller_switch" unchecked>
        <label class="form-check-label" for="controller_switch">Controller</label>
      </div>
    </div>
  </div>

  <br><br>


  <div class="collapse" id="collapsediv2">
    <div class="row text-center">
      <div id="controller_div" class="col">
        <h2 id="start">Move a stick on your controller to start.</h2>
        <br>
        <div id="controllers"></div>
      </div>
    </div>

    <br><br>

    <div class="row text-center
      <div class=" col">
      <div class="form-check">
        <input class="form-check-input" type="radio" name="exampleRadios" id="center_stick" value="center" checked>
        <label class="form-check-label" for="center_stick">
          Center stick is zero throttle
        </label>
      </div>
      <div class="form-check">
        <input class="form-check-input" type="radio" name="exampleRadios" id="full_down_stick" value="full_down">
        <label class="form-check-label" for="full_down_stick">
          Full down stick is zero throttle
        </label>
      </div>
    </div>



    <br><br>

    <div class="row text-center">
      <div class="col">

        <!-- Example Code -->
        <div class="modal fade" id="axis_modal_0" aria-labelledby="axis_modal_Label" tabindex="-1"
          style="display: none;" aria-hidden="true" data-bs-backdrop="static">
          <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="axis_modal_Label_0">Yaw axis</h5>
              </div>
              <div class="modal-body">
                Move the stick along the axis you want to associate to Yaw.
              </div>
              <div class="modal-footer">
                <button id="btn_cancel_0" type="button" class="btn btn-secondary cancel-btn"
                  data-bs-dismiss="modal">Cancel</button>
                <button class="btn btn-primary" data-bs-target="#axis_modal_1" data-bs-toggle="modal" id="btn_modal_0"
                  disabled="true">Proceed</button>
              </div>
            </div>
          </div>
        </div>
        <div class="modal fade" id="axis_modal_1" aria-labelledby="axis_modal_Label_1" tabindex="-1"
          style="display: none;" aria-hidden="true" data-bs-backdrop="static">
          <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="axis_modal_Label_1">Throttle axis</h5>
              </div>
              <div class="modal-body">
                Move the stick along the axis you want to associate to Throttle.
              </div>
              <div class="modal-footer">
                <button id="btn_cancel_1" type="button" class="btn btn-secondary cancel-btn"
                  data-bs-dismiss="modal">Cancel</button>
                <button class="btn btn-primary" data-bs-target="#axis_modal_2" data-bs-toggle="modal" id="btn_modal_1"
                  disabled="true">Proceed</button>
              </div>
            </div>
          </div>
        </div>
        <div class="modal fade" id="axis_modal_2" aria-labelledby="axis_modal_Label_2" tabindex="-1"
          style="display: none;" aria-hidden="true" data-bs-backdrop="static">
          <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="axis_modal_Label_2">Roll axis</h5>
              </div>
              <div class="modal-body">
                Move the stick along the axis you want to associate to Roll.
              </div>
              <div class="modal-footer">
                <button id="btn_cancel_2" type="button" class="btn btn-secondary cancel-btn"
                  data-bs-dismiss="modal">Cancel</button>
                <button class="btn btn-primary" data-bs-target="#axis_modal_3" data-bs-toggle="modal" id="btn_modal_2"
                  disabled="true">Proceed</button>
              </div>
            </div>
          </div>
        </div>
        <div class="modal fade" id="axis_modal_3" aria-labelledby="axis_modal_Label_3" tabindex="-1"
          style="display: none;" aria-hidden="true" data-bs-backdrop="static">
          <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="axis_modal_Label_3">Pitch axis</h5>
              </div>
              <div class="modal-body">
                Move the stick along the axis you want to associate to Pitch.
              </div>
              <div class="modal-footer">
                <button id="btn_cancel_3" type="button" class="btn btn-secondary"
                  data-bs-dismiss="modal">Cancel</button>
                <button class="btn btn-primary" data-bs-dismiss="modal" disabled="true"
                  id="btn_modal_3">Proceed</button>
              </div>
            </div>
          </div>
        </div>
        <button class="btn btn-primary" id="start_modal_button" type="button">
          Configure controller axes
        </button>

        <div id="mapping">
        </div>

      </div>
    </div>
  </div>

</section>
{% endblock content %}

{% block javascript_bottons %}
<script>

  const commandUrl = "{% url 'command' %}";

  function send_yaw_command(btn_id) {

    btn_pressed = btn_id.split('_')[1] + "_" + btn_id.split('_')[2];
    let degrees = document.getElementById("degrees").value;

    if (degrees == 0) {
      alert("degrees is 0.");
      return;
    }

    const command = {
      btn_pressed: btn_pressed,
      velocity: 0,
      degrees: degrees,
      axes: null
    };

    //alert(command["btn_pressed"]);
    exec_command(commandUrl, command);
  }

  function send_direction_command(btn_id) {

    direction = btn_id.split('_')[2];
    let velocity = document.getElementById("velocity").value;

    if (velocity == 0) {
      alert("velocity is 0.");
      return;
    }

    const command = {
      btn_pressed: direction,
      velocity: velocity,
      degrees: 0,
      axes: null
    };

    //alert(command["btn_pressed"]);
    exec_command(commandUrl, command);
  }

  function send_command(btn_id) {

    btn_pressed = btn_id.split('_')[1];

    const command = {
      btn_pressed: btn_pressed,
      velocity: 0,
      degrees: 0,
      axes: null
    };

    //alert(command["btn_pressed"]);
    exec_command(commandUrl, command);
  }


  const dir_btns = document.querySelectorAll('button[id^=btn_dir]');
  dir_btns.forEach(btn => btn.addEventListener("mousedown", () =>
    send_direction_command(btn.id)));

  const yaw_btns = document.querySelectorAll('button[id^=btn_yaw]');
  yaw_btns.forEach(btn => btn.addEventListener("mousedown", () =>
    send_yaw_command(btn.id)));

  const buttons = document.querySelectorAll('button[id^=button]');
  buttons.forEach(btn => btn.addEventListener("mousedown", () =>
    send_command(btn.id)));

  const btns = document.querySelectorAll('button[id^=btn]');
  btns.forEach(btn => {

    btn.addEventListener("mouseup", () => {

      const command = {
        btn_pressed: "stop",
        velocity: 0,
        degrees: 0,
        axes: null
      }
      exec_command(commandUrl, command);
    });
  });

  let checker = document.getElementById('controller_switch');
  checker.onchange = function () {

    if (!!this.checked) {
      document.getElementById('start_modal_button').style.display = 'none';
      show_controller();
      enableListeners();
    }
    else {
      show_buttons();
      disableListeners();
    }
  };

  function show_buttons() {
    $('#collapsediv1').collapse('show');
    $('#collapsediv2').collapse('hide');
  }

  function show_controller() {
    $('#collapsediv1').collapse('hide');
    $('#collapsediv2').collapse('show');
  }

</script>
{% endblock %}

{% block javascript_rc %}
<script>

  let haveEvents = 'GamepadEvent' in window;
  let haveWebkitEvents = 'WebKitGamepadEvent' in window;
  const rAF = window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.requestAnimationFrame;

  const cAF = window.mozCancelAnimationFrame ||
    window.webkitCancelAnimation ||
    window.cancelAnimationFrame;

  const std_mapping_axes = { 0: "yaw", 1: "throttle", 2: "roll", 3: "pitch" };

  // Taranis remote controller's mapping
  //const axes_name = { 0: "roll", 1: "pitch", 2: "throttle", 3: "yaw" };

  const fps = 10;

  const set_mapping_url = `${location.origin}{% url 'set_mapping' %}`;

  const fpsInterval = 1000 / fps;
  const controllers = {};
  let globalID;
  let then = Date.now();
  let enableController = false;
  let controller_calibrated = false;

  // -> Region attributes for calibration 

  const axis_names = { 0: "yaw", 1: "throttle", 2: "roll", 3: "pitch" }
  let current_mapping = { 0: "", 1: "", 2: "", 3: "" }
  let current_axis = "";
  let current_modal = -1;

  let max_value_flag = false;
  let max_axis_value = -1;
  let min_value_flag = false;
  let min_axis_value = -2;

  let center_stick_flag = true;

  // -> End region

  // add listener to checkbox 
  let checked_val = document.querySelector('input[name="exampleRadios"]:checked').value;
  if (document.querySelector('input[name="exampleRadios"]')) {
    document.querySelectorAll('input[name="exampleRadios"]').forEach((elem) => {
      elem.addEventListener("change", function (event) {
        var item = event.target.value;

        center_stick_flag = (item == "center");
      });
    });
  }

  // -> Region functions for modal management
  //    (used for calibration) 

  let btn = document.getElementById("start_modal_button");
  btn.addEventListener("click", function () {

    $("#axis_modal_0").modal("show");
  });

  let modals = document.querySelectorAll('div[id^=axis_modal_]');
  modals.forEach(btn => btn.addEventListener('shown.bs.modal', () => {

    let n = btn.id.split('_')[2];
    current_modal = n;
    current_axis = axis_names[n];
    requestAnimation(updateCalibrationStatus);
  }));
  modals.forEach(btn => btn.addEventListener('hide.bs.modal', () => {

    cancelAnimation();
    current_axis = "";
  }));

  const btn_modal_3 = document.getElementById("btn_modal_3");
  btn_modal_3.addEventListener('click', () => {

    document.getElementById('start_modal_button').style.display = 'none';

    if (Object.keys(controllers).length > 0) {

      // save mapping to database
      set_mapping(set_mapping_url, controllers[0].id, current_mapping);

      addgamepad(controllers[0]);
      controller_calibrated = true;
    }

  });

  const btns_cancel = document.querySelectorAll('button[id^=btn_cancel]');
  btns_cancel.forEach(btn => btn.addEventListener("click", () => {

    cancelAnimation();

    current_mapping = { 0: "", 1: "", 2: "", 3: "" }
    current_axis = "";
    current_modal = -1;

    max_value_flag = false;
    max_axis_value = -1;
    min_value_flag = false;
    min_axis_value = -2;

    for (let i = 0; i < 4; i++) {
      document.getElementById("btn_modal_" + i).disabled = true;
    }
  }));


  function updateCalibrationStatus() {
    scangamepads();

    let j;
    for (j in controllers) {
      print = false;
      const controller = controllers[j];
      for (let i = 0; i < controller.axes.length; i++) {

        if (controller.axes[i].toFixed(4) == parseFloat(1).toFixed(4)) {

          max_axis_value = i;
          max_value_flag = true;
        }
        else if (controller.axes[i].toFixed(4) == parseFloat(-1).toFixed(4)) {

          min_axis_value = i;
          min_value_flag = true;
        }
      }
    }

    if (min_value_flag && max_value_flag && max_axis_value == min_axis_value) {

      //alert("current_mapping[max_axis_value] = " + current_mapping[max_axis_value]);

      if (current_mapping[max_axis_value] === "") {

        document.getElementById("btn_modal_" + current_modal).disabled = false;
        //alert(current_axis + " associated with " + min_axis_value);
        current_mapping[max_axis_value] = current_axis;
        cancelAnimation();
        current_axis = "";
        return;
      }
    }

    requestAnimation(updateCalibrationStatus);
  }

  // --> End modal region

  function connecthandler(e) {
    console.log("CONNECTED.");

    if (Object.keys(controllers).length == 0) {
      // console.log("e.gamepad.id: ", e.gamepad);
      controllers[e.gamepad.index] = e.gamepad;
    }
    else {
      return;
    }

    if (e.gamepad.mapping == "standard") {

      current_mapping = std_mapping_axes;
      addgamepad(e.gamepad);
      controller_calibrated = true;
      document.getElementById('start_modal_button').style.display = "none";
      return;
    }

    requestMapping(e.gamepad);
  }

  function requestMapping(gamepad) {

    const get_mapping_url = "{% url 'get_mapping' 'str' %}".replace('str', gamepad.id)
    get_mapping(get_mapping_url)
      .then(value => {

        console.log(value.data);
        if (value.data === null || value.data === undefined) {

          console.log("button visible.");
          // show modals button to start calibration
          document.getElementById('start_modal_button').style.display = "inline";
        }
        else {

          let m = JSON.parse(value.data)
          let name = m.controller_name;
          let yaw_axis = m.yaw_axis;
          let roll_axis = m.roll_axis;
          let throttle_axis = m.throttle_axis;
          let pitch_axis = m.pitch_axis;

          // set value as current mapping
          current_mapping[yaw_axis] = "yaw";
          current_mapping[roll_axis] = "roll";
          current_mapping[throttle_axis] = "throttle";
          current_mapping[pitch_axis] = "pitch";

          // alert(JSON.stringify(current_mapping));
          addgamepad(gamepad);
          controller_calibrated = true;

          document.getElementById('start_modal_button').style.display = "none";
        }

      });
  }

  function addgamepad(gamepad) {
    //controllers[gamepad.index] = gamepad;

    let d = document.createElement("div");
    d.setAttribute("id", "controller" + gamepad.index);

    // var t = document.createElement("h2");
    // t.appendChild(document.createTextNode("gamepad: " + gamepad.id));
    // d.appendChild(t);

    let a = document.createElement("div");
    a.className = "axes";

    for (i = 0; i < 4/*gamepad.axes.length*/; i++) {
      e = document.createElement("meter");
      e.className = "axis";
      e.setAttribute("min", "-1");
      e.setAttribute("max", "1");
      e.setAttribute("value", "0");
      e.innerHTML = i;

      let f = document.createElement("div");
      f.className = "axes_value";
      f.innerHTML = i;

      a.appendChild(f);
      a.appendChild(e);
    }

    let row_div = document.createElement("div");
    row_div.className = "row";

    let col_div = document.createElement("div");
    col_div.className = "one_column";

    col_div.appendChild(a);
    row_div.appendChild(col_div);
    d.appendChild(row_div);

    let controller_div = document.getElementById("controllers");
    controller_div.appendChild(d);

    document.getElementById("start").style.display = "none";

    requestAnimation(updateStatus);
  }

  function disconnecthandler(e) {
    removegamepad(e.gamepad);
  }

  function removegamepad(gamepad) {
    cancelAnimation();

    let controllers_div = document.getElementById("controllers");
    let d = document.getElementById("controller" + gamepad.index);
    if (d != null) {
      controllers_div.removeChild(d);
    }
    delete controllers[gamepad.index];
    document.getElementById('controller_switch').checked = false;
    show_buttons();
    disableListeners();
    controller_calibrated = false;
    console.log("controller_calibrated: " + controller_calibrated);
  }

  function updateStatus() {

    let checker = document.getElementById('controller_switch');
    if (!!checker.checked == false) {
      console.log("switch is false");
      return;
    }

    scangamepads();

    let axes_dict = {};

    for (j in controllers) {

      let controller = controllers[j];

      let d = document.getElementById("controller" + j);

      let axes = d.getElementsByClassName("axis");
      let axes_values = d.getElementsByClassName("axes_value");
      for (let i = 0; i < 4/*controller.axes.length*/; i++) {

        let val = controller.axes[i].toFixed(2);

        // controllers with standard mapping provide, for vertical axes,
        // negarive values by moving the stick up and positive values 
        // by moving the stick down. On the other hand, if the mapping
        // is not standard, the behavior is opposite. 
        // Therefore we change the sign of the values read 
        // on the two vertical axes if we are in standard
        if (controller.mapping == "standard" && (current_mapping[i] == "throttle" || current_mapping[i] == "pitch")) {
          val = (val * (-1)).toFixed(2);
        }

        if (center_stick_flag == false && current_mapping[i] == "throttle") {
          val = ((parseFloat(val) + 1.00) / 2.00).toFixed(2);
          console.log(val);
        }

        let a = axes[i];
        a.innerHTML = current_mapping[i] + ": " + val;
        a.setAttribute("value", val);

        let f = axes_values[i];
        f.textContent = a.innerHTML;

        axes_dict[current_mapping[i]] = val;
      }
    }

    sendCommand(axes_dict);
    requestAnimation(updateStatus);
  }

  function sendCommand(axes_dict) {

    now = Date.now();
    elapsed = now - then;

    if (elapsed > fpsInterval) {
      then = now - (elapsed % fpsInterval);

      let velocity = document.getElementById("velocity").value;
      let degrees = document.getElementById("degrees").value;

      const command = {
        btn_pressed: "",
        velocity: velocity,
        degrees: degrees,
        axes: axes_dict
      }

      exec_command(commandUrl, command);
    }
  }

  function scangamepads() {
    let gamepads = navigator.getGamepads ? navigator.getGamepads() :
      (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);

    for (let i = 0; i < gamepads.length; i++) {
      if (gamepads[i] && (gamepads[i].index in controllers)) {
        controllers[gamepads[i].index] = gamepads[i];
      }
    }

    if (enableController) {
      // We enter this block only after 
      // the first time the user deactivates 
      // and re-activate the controller switch 
      reEnableControllerInput();
    }
  }

  /**
   * re-enables input from the controller if 
   * the switch is active and there are controllers 
   * that are found to be already connected
   */
  function reEnableControllerInput() {

    let checker = document.getElementById('controller_switch');
    if ((!!checker.checked) == true && Object.keys(controllers).length > 0 && controller_calibrated == true) {

      enableController = false;

      // restart the animation by which
      // we start taking controller input
      requestAnimation(updateStatus);
    }
  }

  function enableListeners() {

    if (haveEvents) {

      window.addEventListener("gamepadconnected", connecthandler);
      window.addEventListener("gamepaddisconnected", disconnecthandler);
    }
    else if (haveWebkitEvents) {
      window.addEventListener("webkitgamepadconnected", connecthandler);
      window.addEventListener("webkitgamepaddisconnected", disconnecthandler);
    }
    else {
      setInterval(scangamepads, 500);
    }

    scangamepads();
  }

  function disableListeners() {

    // the next time the switch is active, this boolean
    // will be used to re-enable controller's input
    enableController = true;

    if (haveEvents) {
      window.removeEventListener("gamepadconnected", connecthandler);
      window.removeEventListener("gamepaddisconnected", disconnecthandler);
    }
    else if (haveWebkitEvents) {
      window.removeEventListener("webkitgamepadconnected", connecthandler);
      window.removeEventListener("webkitgamepaddisconnected", disconnecthandler);
    }
    else {
      clearInterval(scangamepads);
    }

    cancelAnimation();
  }

  function requestAnimation(fun) {

    console.log("Requesting AnimationFrame...");
    globalID = rAF(fun);
  }

  function cancelAnimation() {
    console.log("Cancelling AnimationFrame...");
    cAF(globalID);
  }

</script>
{% endblock %}